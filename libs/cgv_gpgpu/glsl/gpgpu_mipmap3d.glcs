#version 430

#define IMAGE_FORMAT r8
#define NUM_COMPONENTS 1

#if NUM_COMPONENTS == 1
	#define DATA_TYPE float
	#define ACCESS_MASK r
	#define STORE_VALUE vec4(result)
#elif  NUM_COMPONENTS == 2
	#define DATA_TYPE vec2
	#define ACCESS_MASK rg
	#define STORE_VALUE vec4(result, 0.0, 0.0)
#elif  NUM_COMPONENTS == 3
	#define DATA_TYPE vec3
	#define ACCESS_MASK rgb
	#define STORE_VALUE vec4(result, 0.0)
#else
	#define DATA_TYPE vec4
	#define ACCESS_MASK rgba
	#define STORE_VALUE result
#endif

layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

layout(binding = 0) uniform sampler3D input_tex;
layout(binding = 1, IMAGE_FORMAT) uniform writeonly image3D output_tex;

uniform uint level;
uniform uvec3 output_size;

DATA_TYPE sample_texture(in vec3 coords) {
	
	return textureLod(input_tex, coords, level).ACCESS_MASK;
}

void main() {
	
	// the texel coordinates of this thread
    ivec3 idx = ivec3(gl_GlobalInvocationID);
    
	// this produces correct results even for odd sized input textures
	if(idx.x < output_size.x && idx.y < output_size.y && idx.z < output_size.z) {
		vec3 output_size_float = vec3(output_size);
		vec3 double_size = 2.0 * output_size_float;

		vec3 fidx = idx / output_size_float;
		vec3 fstep = 1.0 / double_size;
		fidx += 0.5 * fstep;

		DATA_TYPE result = 0.0;
		// use texture sampler filtering to average samples
		result += sample_texture(fidx + vec3(0.0, 0.0, 0.0));
		result += sample_texture(fidx + vec3(fstep.x, 0.0, 0.0));
		result += sample_texture(fidx + vec3(0.0, fstep.y, 0.0));
		result += sample_texture(fidx + vec3(fstep.x, fstep.y, 0.0));
		result += sample_texture(fidx + vec3(0.0, 0.0, fstep.z));
		result += sample_texture(fidx + vec3(fstep.x, 0.0, fstep.z));
		result += sample_texture(fidx + vec3(0.0, fstep.y, fstep.z));
		result += sample_texture(fidx + vec3(fstep.x, fstep.y, fstep.z));

		result /= 8.0;

		imageStore(output_tex, idx, STORE_VALUE);
	}
}
