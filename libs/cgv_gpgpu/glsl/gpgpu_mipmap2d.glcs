#version 430

#define IMAGE_FORMAT r8
#define NUM_COMPONENTS 1

#if NUM_COMPONENTS == 1
	#define DATA_TYPE float
	#define ACCESS_MASK r
	#define STORE_VALUE vec4(result)
#elif  NUM_COMPONENTS == 2
	#define DATA_TYPE vec2
	#define ACCESS_MASK rg
	#define STORE_VALUE vec4(result, 0.0, 0.0)
#elif  NUM_COMPONENTS == 3
	#define DATA_TYPE vec3
	#define ACCESS_MASK rgb
	#define STORE_VALUE vec4(result, 0.0)
#else
	#define DATA_TYPE vec4
	#define ACCESS_MASK rgba
	#define STORE_VALUE result
#endif

layout(local_size_x = 4, local_size_y = 4) in;

layout(binding = 0) uniform sampler2D input_tex;
layout(binding = 1, IMAGE_FORMAT) uniform writeonly image2D output_tex;

uniform uint level;
uniform uvec2 output_size;

DATA_TYPE sample_texture(in vec2 coords) {
	
	return textureLod(input_tex, coords, level).ACCESS_MASK;
}

void main() {
	
	// the texel coordinates of this thread
    ivec2 idx = ivec2(gl_GlobalInvocationID);
    
	// this produces correct results even for odd sized input textures
	if(idx.x < output_size.x && idx.y < output_size.y) {
		vec2 output_size_float = vec2(output_size);
		vec2 double_size = 2.0 * output_size_float;

		vec2 fidx = idx / output_size_float;
		vec2 fstep = 1.0 / double_size;
		fidx += 0.5 * fstep;

		DATA_TYPE result = 0.0;
		// use texture sampler filtering to average samples
		result += sample_texture(fidx + vec2(0.0, 0.0));
		result += sample_texture(fidx + vec2(fstep.x, 0.0));
		result += sample_texture(fidx + vec2(0.0, fstep.y));
		result += sample_texture(fidx + vec2(fstep.x, fstep.y));
		
		result /= 4.0;

		imageStore(output_tex, idx, STORE_VALUE);
	}
}
